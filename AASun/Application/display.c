/*
----------------------------------------------------------------------

	Alain Chebrou

	SH1106.c	Simplified library for 128x64 OLED display with SH1106/SSD1306 controller IC
				To display text with 7x8 (8 lines) or 9x16 (4 lines) fonts.
				Can display simple bitmap
				SPI interface only, with DMA (No I2C)
				Use 1KB of RAM as screen buffer

				Buttons        processing
				Pulse counters processing
				Digital input  processing
				Manage display page content

	When		Who	What
	07/12/22	ac	Creation
	16/06/23	ac	Add DMA to displayUpdate() => screen update < 1ms
	05/05/24	ac	Add SSD1306 controller driver (0.96" OLED display)


				for SSD1306:
				https://github.com/tejashwikalptaru/ssd1306xled/blob/master/ssd1306xled.cpp
				https://github.com/gzone0111/STM32_MPU6050_WITH_OLED_SSD1315/blob/main/Core/Src/ssd1306.c
				https://www.electronicwings.com/sensors-modules/ssd1306-oled-display
				https://picaxeforum.co.uk/threads/fyi-comparing-the-ssd1306-and-sh1106-oled-drivers.32387/

----------------------------------------------------------------------
*/

#include "aa.h"
#include "aakernel.h"	// For critical section
#include "gpiobasic.h"

#include "AASun.h"
#include "display.h"
#include "spi.h"
#include "util.h"

#include "string.h"		// memset

//--------------------------------------------------------------------------------
// GPIO definition

#define	CS_PORT		GPIOD		// Display chip select
#define	CS_PIN		0

#define	DC_PORT		GPIOD		// Display Data/Command
#define	DC_PIN		1

#define	RST_PORT	GPIOD		// Display Reset
#define	RST_PIN		2

// All this is resolved into constants at compile time to get the minimal code.
// BSRR register: low half word to set the GPIO, high half word to reset the GPIO

#define	csSet()		CS_PORT->BSRR = (1u << (CS_PIN + 16))	// CS set active (CS is active low)
#define	csReset()	CS_PORT->BSRR = (1u << CS_PIN)

#define	dcData()	DC_PORT->BSRR = (1u << DC_PIN)			// Set to high : Data
#define	dcCmd()		DC_PORT->BSRR = (1u << (DC_PIN + 16))	// Set to low  : command

#define	rstOff()	RST_PORT->BSRR = (1u << RST_PIN)		// Reset is active low
#define	rstOn()		RST_PORT->BSRR = (1u << (RST_PIN + 16))

//--------------------------------------------------------------------------------

#define SSD1306_SETLOWCOLUMN	0x00	// CMD Set Lower  Column Address (2 because SH1106 has a X origin offset of 2!!!)
#define SH1106_SETLOWCOLUMN		0x02	// CMD Set Lower  Column Address (2 because SH1106 has a X origin offset of 2!!!)
#define SH1106_SETHIGHCOLUMN	0x10	// CMD Set Higher Column Address
#define	SH1106_SETPAGEADDR		0xB0	// CMD Set Page Address

//--------------------------------------------------------------------------------

static	void displayWrCmd	(unsigned cmd) ;
static	void displayWrData	(unsigned data) ;

//--------------------------------------------------------------------------------

// The video memory is divided into 8 pages in total
// 8 lines per page, 128 pixels per line
// The storage format is as follows
//[0]0 1 2 3 ... 127 (0~7)  line	   
//[1]0 1 2 3 ... 127 (8~15) line	
//[2]0 1 2 3 ... 127 (16~23)line	
//[3]0 1 2 3 ... 127 (24~31)line	
//[4]0 1 2 3 ... 127 (32~39)line	
//[5]0 1 2 3 ... 127 (40~47)line	
//[6]0 1 2 3 ... 127 (48~55)line	
//[7]0 1 2 3 ... 127 (56~63)line			   

// Each bit of the array stores the color value of one pixel of the OLED:
// 1-bright/white, 0-off/black (when the display is not inverted).
// Each array byte represents 1 column of 8 pixels, the LSB bit at the top.

static uint8_t displayBuffer[1024] ;

//--------------------------------------------------------------------------------
// This package defines 2 fonts
// A small font  7x8 : use 1 page height, 128 / 7 = 18 char per display line
// A big   font 9x16 : use 2 page height, 128 / 9 = 14 char per display line

// The characters top can only be set on Y page boundary (0, 8, 16...)
// For small font the maximum Y is 56, for the big font the maximum Y is 48.
// The displayChar() function enforce this limit.

#define	FONT_SMALL_W	7					// Pixel
#define	FONT_SMALL_H	8					// Pixel
#define	FONT_SMALL_NL	(128/FONT_SMALL_W)	// Count of char per display line

const uint8_t font6x8 [][8] =
 {
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// ' '
	{ 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x00 },	// '!'
	{ 0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00 },	// '"'
	{ 0x00, 0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00, 0x00 },	// '#'
	{ 0x00, 0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00, 0x00 },	// '$'
	{ 0x00, 0x62, 0x64, 0x08, 0x16, 0x06, 0x00, 0x00 },	// '%'
	{ 0x00, 0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00 },	// '&'
	{ 0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00 },	// '''
	{ 0x00, 0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x00 },	// '('
	{ 0x00, 0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00 },	// ')'
	{ 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00, 0x00 },	// '*'
	{ 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00 },	// '+'
	{ 0x00, 0x00, 0x00, 0xA0, 0x60, 0x00, 0x00, 0x00 },	// ','
	{ 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00 },	// '-'
	{ 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00 },	// '.'
	{ 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00 },	// '/'
	{ 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x00 },	// '0'
	{ 0x00, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, 0x00 },	// '1'
	{ 0x00, 0x42, 0x61, 0x51, 0x49, 0x46, 0x00, 0x00 },	// '2'
	{ 0x00, 0x21, 0x41, 0x45, 0x4B, 0x31, 0x00, 0x00 },	// '3'
	{ 0x00, 0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x00 },	// '4'
	{ 0x00, 0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00 },	// '5'
	{ 0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, 0x00 },	// '6'
	{ 0x00, 0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00 },	// '7'
	{ 0x00, 0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00 },	// '8'
	{ 0x00, 0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00 },	// '9'
	{ 0x00, 0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00 },	// ':'
	{ 0x00, 0x00, 0x56, 0x36, 0x00, 0x00, 0x00, 0x00 },	// ';'
	{ 0x00, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00 },	// '<'
	{ 0x00, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00 },	// '='
	{ 0x00, 0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x00 },	// '>'
	{ 0x00, 0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00 },	// '?'
	{ 0x00, 0x32, 0x49, 0x59, 0x51, 0x3E, 0x00, 0x00 },	// '@'
	{ 0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C, 0x00, 0x00 },	// 'A'
	{ 0x00, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00 },	// 'B'
	{ 0x00, 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00 },	// 'C'
	{ 0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, 0x00 },	// 'D'
	{ 0x00, 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00 },	// 'E'
	{ 0x00, 0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00 },	// 'F'
	{ 0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00, 0x00 },	// 'G'
	{ 0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x00 },	// 'H'
	{ 0x00, 0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, 0x00 },	// 'I'
	{ 0x00, 0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, 0x00 },	// 'J'
	{ 0x00, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00 },	// 'K'
	{ 0x00, 0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00 },	// 'L'
	{ 0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00, 0x00 },	// 'M'
	{ 0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, 0x00 },	// 'N'
	{ 0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x00 },	// 'O'
	{ 0x00, 0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00 },	// 'P'
	{ 0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, 0x00 },	// 'Q'
	{ 0x00, 0x7F, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00 },	// 'R'
	{ 0x00, 0x46, 0x49, 0x49, 0x49, 0x31, 0x00, 0x00 },	// 'S'
	{ 0x00, 0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x00 },	// 'T'
	{ 0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x00 },	// 'U'
	{ 0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x00 },	// 'V'
	{ 0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00, 0x00 },	// 'W'
	{ 0x00, 0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00 },	// 'X'
	{ 0x00, 0x07, 0x08, 0x70, 0x08, 0x07, 0x00, 0x00 },	// 'Y'
	{ 0x00, 0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00 },	// 'Z'
	{ 0x00, 0x00, 0x7F, 0x41, 0x41, 0x00, 0x00, 0x00 },	// '['
	{ 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00 },	// '\'
	{ 0x00, 0x00, 0x41, 0x41, 0x7F, 0x00, 0x00, 0x00 },	// ']'
	{ 0x00, 0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00 },	// '^'
	{ 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00 },	// '_'
	{ 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00 },	// '`'
	{ 0x00, 0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00 },	// 'a'
	{ 0x00, 0x7F, 0x48, 0x44, 0x44, 0x38, 0x00, 0x00 },	// 'b'
	{ 0x00, 0x38, 0x44, 0x44, 0x44, 0x20, 0x00, 0x00 },	// 'c'
	{ 0x00, 0x38, 0x44, 0x44, 0x48, 0x7F, 0x00, 0x00 },	// 'd'
	{ 0x00, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x00 },	// 'e'
	{ 0x00, 0x08, 0x7F, 0x09, 0x01, 0x02, 0x00, 0x00 },	// 'f'
	{ 0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C, 0x00, 0x00 },	// 'g'
	{ 0x00, 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00 },	// 'h'
	{ 0x00, 0x00, 0x44, 0x7D, 0x40, 0x00, 0x00, 0x00 },	// 'i'
	{ 0x00, 0x40, 0x80, 0x84, 0x7D, 0x00, 0x00, 0x00 },	// 'j'
	{ 0x00, 0x7F, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00 },	// 'k'
	{ 0x00, 0x00, 0x41, 0x7F, 0x40, 0x00, 0x00, 0x00 },	// 'l'
	{ 0x00, 0x7C, 0x04, 0x18, 0x04, 0x78, 0x00, 0x00 },	// 'm'
	{ 0x00, 0x7C, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00 },	// 'n'
	{ 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00 },	// 'o'
	{ 0x00, 0xFC, 0x18, 0x24, 0x24, 0x18, 0x00, 0x00 },	// 'p'
	{ 0x00, 0x18, 0x24, 0x24, 0x18, 0xFC, 0x00, 0x00 },	// 'q'
	{ 0x00, 0x7C, 0x08, 0x04, 0x04, 0x08, 0x00, 0x00 },	// 'r'
	{ 0x00, 0x48, 0x54, 0x54, 0x54, 0x24, 0x00, 0x00 },	// 's'
	{ 0x00, 0x04, 0x3F, 0x44, 0x40, 0x20, 0x00, 0x00 },	// 't'
	{ 0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00, 0x00 },	// 'u'
	{ 0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, 0x00 },	// 'v'
	{ 0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00, 0x00 },	// 'w'
	{ 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00 },	// 'x'
	{ 0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C, 0x00, 0x00 },	// 'y'
	{ 0x00, 0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x00 },	// 'z'
	{ 0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x00 },	// '{'
	{ 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00 },	// '|'
	{ 0x00, 0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00 },	// '}'
	{ 0x00, 0x10, 0x08, 0x10, 0x20, 0x10, 0x00, 0x00 },	// '~'
} ;

/* Font Information:
 * Modern DOS is a raster monospace serif based on IBM and Verite, extracted from VGA ROM typefaces
 * in real machines by various manufacturers, created with FontForge.
 * Source files available on NotABug: https://notabug.org/HarvettFox96/ttf-moderndos
 *
 * This typeface is made by Jayvee Enaguas (HarvettFox96), licensed under a Creative Commons Zero
 * (CC0) 1.0. © 2009-2018.
 *
 * 128 / 9 = 14 char per display line
 */

#define	FONT_BIG_W		9					// Pixel
#define	FONT_BIG_H		16					// Pixel
#define	FONT_BIG_NL		(128/FONT_BIG_W)	// Count of char per display line

const uint8_t font8x16 [] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// ' '
	0x00, 0x00, 0x38, 0xfc, 0xfc, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x0d, 0x00, 0x00, 0x00,	// '!'
	0x00, 0x06, 0x1e, 0x00, 0x00, 0x06, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// '"'
	0x40, 0xf0, 0xf0, 0x40, 0xf0, 0xf0, 0x40, 0x00, 0x02, 0x0f, 0x0f, 0x02, 0x0f, 0x0f, 0x02, 0x00,	// '#'
	0x30, 0x78, 0xc8, 0xfe, 0x88, 0x38, 0x30, 0x00, 0x06, 0x0e, 0x08, 0x3f, 0x09, 0x0f, 0x06, 0x00,	// '$'
	0x18, 0x24, 0xa4, 0xd8, 0x60, 0x30, 0x18, 0x00, 0x06, 0x03, 0x01, 0x06, 0x09, 0x09, 0x06, 0x00,	// '%'
	0x00, 0x98, 0xfc, 0xe4, 0x3c, 0x98, 0x80, 0x00, 0x07, 0x0f, 0x08, 0x09, 0x07, 0x0f, 0x08, 0x00,	// '&'
	0x00, 0x00, 0x00, 0x16, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// '''
	0x00, 0x00, 0xf0, 0xf8, 0x0c, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x0c, 0x08, 0x00, 0x00,	// '('
	0x00, 0x00, 0x04, 0x0c, 0xf8, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0c, 0x07, 0x03, 0x00, 0x00,	// ')'
	0x80, 0xa0, 0xe0, 0xc0, 0xc0, 0xe0, 0xa0, 0x80, 0x00, 0x02, 0x03, 0x01, 0x01, 0x03, 0x02, 0x00,	// '*'
	0x00, 0x80, 0x80, 0xe0, 0xe0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00,	// '+'
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x1c, 0x00, 0x00, 0x00, 0x00,	// ','
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// '-'
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00,	// '.'
	0x00, 0x00, 0x80, 0xc0, 0x60, 0x30, 0x18, 0x00, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,	// '/'
	0xf8, 0xfc, 0x84, 0xc4, 0x64, 0xfc, 0xf8, 0x00, 0x07, 0x0f, 0x09, 0x08, 0x08, 0x0f, 0x07, 0x00,	// '0'
	0x00, 0x10, 0x18, 0xfc, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x0f, 0x0f, 0x08, 0x08, 0x00,	// '1'
	0x08, 0x0c, 0x84, 0xc4, 0x64, 0x3c, 0x18, 0x00, 0x0e, 0x0f, 0x09, 0x08, 0x08, 0x0c, 0x0c, 0x00,	// '2'
	0x08, 0x0c, 0x44, 0x44, 0x44, 0xfc, 0xb8, 0x00, 0x04, 0x0c, 0x08, 0x08, 0x08, 0x0f, 0x07, 0x00,	// '3'
	0xc0, 0xe0, 0x30, 0x18, 0xfc, 0xfc, 0x00, 0x00, 0x01, 0x01, 0x01, 0x09, 0x0f, 0x0f, 0x09, 0x00,	// '4'
	0x7c, 0x7c, 0x44, 0x44, 0x44, 0xc4, 0x84, 0x00, 0x04, 0x0c, 0x08, 0x08, 0x08, 0x0f, 0x07, 0x00,	// '5'
	0xf8, 0xfc, 0x44, 0x44, 0x44, 0xcc, 0x88, 0x00, 0x07, 0x0f, 0x08, 0x08, 0x08, 0x0f, 0x07, 0x00,	// '6'
	0x0c, 0x0c, 0x04, 0x84, 0xc4, 0x7c, 0x3c, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00,	// '7'
	0xb8, 0xfc, 0x44, 0x44, 0x44, 0xfc, 0xb8, 0x00, 0x07, 0x0f, 0x08, 0x08, 0x08, 0x0f, 0x07, 0x00,	// '8'
	0x78, 0xfc, 0x84, 0x84, 0x84, 0xfc, 0xf8, 0x00, 0x04, 0x0c, 0x08, 0x08, 0x08, 0x0f, 0x07, 0x00,	// '9'
	0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0x00, 0x00, 0x00,	// ':'
	0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x0e, 0x00, 0x00, 0x00,	// ';'
	0x00, 0x80, 0xc0, 0x60, 0x30, 0x18, 0x08, 0x00, 0x00, 0x00, 0x01, 0x03, 0x06, 0x0c, 0x08, 0x00,	// '<'
	0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,	// '='
	0x00, 0x08, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00, 0x00, 0x08, 0x0c, 0x06, 0x03, 0x01, 0x00, 0x00,	// '>'
	0x18, 0x1c, 0x04, 0x84, 0xc4, 0x7c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x0d, 0x00, 0x00, 0x00,	// '?'
	0xe0, 0x10, 0xc8, 0x28, 0x28, 0xe8, 0x10, 0xe0, 0x03, 0x04, 0x0b, 0x0a, 0x09, 0x0b, 0x02, 0x01,	// '@'
	0xf0, 0xf8, 0x8c, 0x84, 0x8c, 0xf8, 0xf0, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x00,	// 'A'
	0x04, 0xfc, 0xfc, 0x44, 0x44, 0xfc, 0xb8, 0x00, 0x08, 0x0f, 0x0f, 0x08, 0x08, 0x0f, 0x07, 0x00,	// 'B'
	0xf8, 0xfc, 0x04, 0x04, 0x04, 0x1c, 0x18, 0x00, 0x07, 0x0f, 0x08, 0x08, 0x08, 0x0e, 0x06, 0x00,	// 'C'
	0x04, 0xfc, 0xfc, 0x04, 0x04, 0xfc, 0xf8, 0x00, 0x08, 0x0f, 0x0f, 0x08, 0x08, 0x0f, 0x07, 0x00,	// 'D'
	0x04, 0xfc, 0xfc, 0xc4, 0xe4, 0x0c, 0x1c, 0x00, 0x08, 0x0f, 0x0f, 0x08, 0x09, 0x0c, 0x0e, 0x00,	// 'E'
	0x04, 0xfc, 0xfc, 0xc4, 0xe4, 0x0c, 0x1c, 0x00, 0x08, 0x0f, 0x0f, 0x08, 0x01, 0x00, 0x00, 0x00,	// 'F'
	0xf8, 0xfc, 0x04, 0x04, 0x84, 0x9c, 0x98, 0x00, 0x07, 0x0f, 0x08, 0x08, 0x08, 0x0f, 0x0f, 0x00,	// 'G'
	0xfc, 0xfc, 0x40, 0x40, 0x40, 0xfc, 0xfc, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x00,	// 'H'
	0x00, 0x00, 0x04, 0xfc, 0xfc, 0x04, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0f, 0x0f, 0x08, 0x00, 0x00,	// 'I'
	0x00, 0x00, 0x00, 0x04, 0xfc, 0xfc, 0x04, 0x00, 0x06, 0x0e, 0x08, 0x08, 0x0f, 0x07, 0x00, 0x00,	// 'J'
	0x04, 0xfc, 0xfc, 0xc0, 0xe0, 0x3c, 0x1c, 0x00, 0x08, 0x0f, 0x0f, 0x00, 0x01, 0x0f, 0x0e, 0x00,	// 'K'
	0x04, 0xfc, 0xfc, 0x04, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0f, 0x0f, 0x08, 0x08, 0x0c, 0x0e, 0x00,	// 'L'
	0xfc, 0xf8, 0x70, 0xe0, 0x70, 0xf8, 0xfc, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x00,	// 'M'
	0xfc, 0xf8, 0x70, 0xe0, 0xc0, 0xfc, 0xfc, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x01, 0x0f, 0x0f, 0x00,	// 'N'
	0xf8, 0xfc, 0x04, 0x04, 0x04, 0xfc, 0xf8, 0x00, 0x07, 0x0f, 0x08, 0x08, 0x08, 0x0f, 0x07, 0x00,	// 'O'
	0x04, 0xfc, 0xfc, 0x84, 0x84, 0xfc, 0x78, 0x00, 0x08, 0x0f, 0x0f, 0x08, 0x00, 0x00, 0x00, 0x00,	// 'P'
	0xf8, 0xfc, 0x04, 0x04, 0x04, 0xfc, 0xf8, 0x00, 0x07, 0x0f, 0x08, 0x0e, 0x0c, 0x1f, 0x17, 0x00,	// 'Q'
	0x04, 0xfc, 0xfc, 0x84, 0x84, 0xfc, 0x78, 0x00, 0x08, 0x0f, 0x0f, 0x00, 0x01, 0x0f, 0x0e, 0x00,	// 'R'
	0x18, 0x3c, 0x64, 0x44, 0xc4, 0x9c, 0x18, 0x00, 0x06, 0x0e, 0x08, 0x08, 0x08, 0x0f, 0x07, 0x00,	// 'S'
	0x00, 0x1c, 0x0c, 0xfc, 0xfc, 0x0c, 0x1c, 0x00, 0x00, 0x00, 0x08, 0x0f, 0x0f, 0x08, 0x00, 0x00,	// 'T'
	0xfc, 0xfc, 0x00, 0x00, 0x00, 0xfc, 0xfc, 0x00, 0x07, 0x0f, 0x08, 0x08, 0x08, 0x0f, 0x07, 0x00,	// 'U'
	0xfc, 0xfc, 0x00, 0x00, 0x00, 0xfc, 0xfc, 0x00, 0x01, 0x03, 0x06, 0x0c, 0x06, 0x03, 0x01, 0x00,	// 'V'
	0xfc, 0xfc, 0x00, 0x80, 0x00, 0xfc, 0xfc, 0x00, 0x0f, 0x07, 0x03, 0x01, 0x03, 0x07, 0x0f, 0x00,	// 'W'
	0x0c, 0x3c, 0xf0, 0xe0, 0xf0, 0x3c, 0x0c, 0x00, 0x0c, 0x0f, 0x03, 0x01, 0x03, 0x0f, 0x0c, 0x00,	// 'X'
	0x00, 0x3c, 0x7c, 0xc0, 0xc0, 0x7c, 0x3c, 0x00, 0x00, 0x00, 0x08, 0x0f, 0x0f, 0x08, 0x00, 0x00,	// 'Y'
	0x1c, 0x0c, 0x84, 0xc4, 0x64, 0x3c, 0x1c, 0x00, 0x0e, 0x0f, 0x09, 0x08, 0x08, 0x0c, 0x0e, 0x00,	// 'Z'
	0x00, 0x00, 0xfc, 0xfc, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x08, 0x08, 0x00, 0x00,	// '['
	0x18, 0x30, 0x60, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x06, 0x00,	// '\'
	0x00, 0x00, 0x04, 0x04, 0xfc, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x0f, 0x0f, 0x00, 0x00,	// ']'
	0x20, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// '^'
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,	// '_'
	0x00, 0x00, 0x00, 0x0e, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// '`'
	0x00, 0xa0, 0xa0, 0xa0, 0xe0, 0xc0, 0x00, 0x00, 0x07, 0x0f, 0x08, 0x08, 0x07, 0x0f, 0x08, 0x00,	// 'a'
	0x04, 0xfc, 0xfc, 0x20, 0x20, 0xe0, 0xc0, 0x00, 0x00, 0x0f, 0x0f, 0x08, 0x08, 0x0f, 0x07, 0x00,	// 'b'
	0xc0, 0xe0, 0x20, 0x20, 0x20, 0x60, 0x40, 0x00, 0x07, 0x0f, 0x08, 0x08, 0x08, 0x0c, 0x04, 0x00,	// 'c'
	0xc0, 0xe0, 0x20, 0x24, 0xfc, 0xfc, 0x00, 0x00, 0x07, 0x0f, 0x08, 0x08, 0x07, 0x0f, 0x08, 0x00,	// 'd'
	0xc0, 0xe0, 0x20, 0x20, 0x20, 0xe0, 0xc0, 0x00, 0x07, 0x0f, 0x09, 0x09, 0x09, 0x0d, 0x05, 0x00,	// 'e'
	0x00, 0x20, 0xf8, 0xfc, 0x24, 0x2c, 0x08, 0x00, 0x00, 0x08, 0x0f, 0x0f, 0x08, 0x00, 0x00, 0x00,	// 'f'
	0xc0, 0xe0, 0x20, 0x20, 0xc0, 0xe0, 0x20, 0x00, 0x27, 0x6f, 0x48, 0x48, 0x7f, 0x3f, 0x00, 0x00,	// 'g'
	0x04, 0xfc, 0xfc, 0x40, 0x20, 0xe0, 0xc0, 0x00, 0x08, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x0f, 0x00,	// 'h'
	0x00, 0x00, 0x20, 0xec, 0xec, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0f, 0x0f, 0x08, 0x00, 0x00,	// 'i'
	0x00, 0x00, 0x00, 0x20, 0xec, 0xec, 0x00, 0x00, 0x30, 0x70, 0x40, 0x40, 0x7f, 0x3f, 0x00, 0x00,	// 'j'
	0x04, 0xfc, 0xfc, 0x80, 0xc0, 0x60, 0x20, 0x00, 0x08, 0x0f, 0x0f, 0x01, 0x03, 0x0e, 0x0c, 0x00,	// 'k'
	0x00, 0x00, 0x04, 0xfc, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0f, 0x0f, 0x08, 0x00, 0x00,	// 'l'
	0xe0, 0xe0, 0x60, 0xc0, 0x60, 0xe0, 0xc0, 0x00, 0x0f, 0x0f, 0x00, 0x07, 0x00, 0x0f, 0x0f, 0x00,	// 'm'
	0x20, 0xe0, 0xc0, 0x20, 0x20, 0xe0, 0xc0, 0x00, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x0f, 0x00,	// 'n'
	0xc0, 0xe0, 0x20, 0x20, 0x20, 0xe0, 0xc0, 0x00, 0x07, 0x0f, 0x08, 0x08, 0x08, 0x0f, 0x07, 0x00,	// 'o'
	0x20, 0xe0, 0xc0, 0x20, 0x20, 0xe0, 0xc0, 0x00, 0x40, 0x7f, 0x7f, 0x48, 0x08, 0x0f, 0x07, 0x00,	// 'p'
	0xc0, 0xe0, 0x20, 0x20, 0xe0, 0xe0, 0x00, 0x00, 0x07, 0x0f, 0x08, 0x48, 0x7f, 0x7f, 0x40, 0x00,	// 'q'
	0x20, 0xe0, 0xc0, 0x60, 0x20, 0x60, 0x60, 0x00, 0x08, 0x0f, 0x0f, 0x08, 0x00, 0x00, 0x00, 0x00,	// 'r'
	0x40, 0xe0, 0xa0, 0x20, 0x20, 0x60, 0x40, 0x00, 0x04, 0x0c, 0x09, 0x09, 0x0b, 0x0e, 0x04, 0x00,	// 's'
	0x20, 0x20, 0xf8, 0xfc, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0f, 0x08, 0x04, 0x00, 0x00,	// 't'
	0xe0, 0xe0, 0x00, 0x00, 0xe0, 0xe0, 0x00, 0x00, 0x07, 0x0f, 0x08, 0x08, 0x07, 0x0f, 0x08, 0x00,	// 'u'
	0xe0, 0xe0, 0x00, 0x00, 0x00, 0xe0, 0xe0, 0x00, 0x01, 0x03, 0x06, 0x0c, 0x06, 0x03, 0x01, 0x00,	// 'v'
	0xe0, 0xe0, 0x00, 0xc0, 0x00, 0xe0, 0xe0, 0x00, 0x07, 0x0f, 0x0c, 0x07, 0x0c, 0x0f, 0x07, 0x00,	// 'w'
	0x60, 0xe0, 0x80, 0x00, 0x80, 0xe0, 0x60, 0x00, 0x0c, 0x0e, 0x03, 0x01, 0x03, 0x0e, 0x0c, 0x00,	// 'x'
	0xe0, 0xe0, 0x00, 0x00, 0x00, 0xe0, 0xe0, 0x00, 0x47, 0x4f, 0x48, 0x48, 0x68, 0x3f, 0x1f, 0x00,	// 'y'
	0x60, 0x20, 0x20, 0xa0, 0xe0, 0x60, 0x20, 0x00, 0x0c, 0x0e, 0x0b, 0x09, 0x08, 0x08, 0x0c, 0x00,	// 'z'
	0x00, 0x40, 0x40, 0xf8, 0xbc, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0f, 0x08, 0x08, 0x00,	// '{'
	0x00, 0x00, 0x00, 0x3c, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x00,	// '|'
	0x00, 0x04, 0x04, 0xbc, 0xf8, 0x40, 0x40, 0x00, 0x00, 0x08, 0x08, 0x0f, 0x07, 0x00, 0x00, 0x00,	// '}'
	0x08, 0x0c, 0x04, 0x0c, 0x08, 0x0c, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  	// '~'
} ;

static	uint32_t	cx, cy ;			// Virtual cursor position (top left of the char)
static	uint32_t	currentFont ;		// 8 or 16
static	uint32_t	currentFontNL ;

//--------------------------------------------------------------------------------
// Set font for next char display
// fontType is FONT_SMALL or FONT_BIG

void	displaySetFont		(uint32_t fontType)
{
	if (fontType == FONT_SMALL  ||  fontType == FONT_BIG)
	{
		currentFont = fontType ;
		if (fontType == FONT_SMALL)
		{
			currentFontNL = FONT_SMALL_NL ;
		}
		else
		{
			currentFontNL = FONT_BIG_NL ;
		}
	}
}

//--------------------------------------------------------------------------------

void	displayChar (char cc)
{
	uint8_t		* pBuffer ;
	uint8_t		const * pChar ;
	uint32_t	ii ;

	cy = (cy + 7) & 0x038 ;		// Adjust cy to next multiple of 8, less than 64 (the line count)
	pBuffer = & displayBuffer [((cy / 8) * DISPLAY_WIDTH) + cx] ; // Where to copy the char bitmap

	if (currentFont == 8)
	{
		// Small font 7x8
		if (cc == '\n')
		{
			// Next line
			cx = 0 ;
			cy = (cy + 8) & 0x3F ;
		}
		else
		{
			pChar = & font6x8 [cc - ' '][0] ;
			for (ii = 0 ; ii < 7 ; ii++)
			{
				* pBuffer++ = * pChar++ ;
				// Protect displayBuffer overflow
				if (pBuffer >= & displayBuffer [sizeof (displayBuffer)])
				{
					pBuffer = displayBuffer ;
				}
			}
			// Increment the virtual cursor position
			cx += 7 ;
			if (cx > 127)
			{
				cx -= 128 ;
				cy = (cy + 8) & 0x3F ;
			}
		}
	}
	else
	{
		// Big font9x16
		if (cy > 48)
		{
			cy = 48 ;	// Avoid displayBuffer overflow
		}
		if (cc == '\n')
		{
			// Next line
			cx = 0 ;
			cy = (cy + 16) & 0x3F ;
		}
		else
		{
			pChar = & font8x16 [(cc - ' ') * 16] ;
			for (ii = 0 ; ii < 8 ; ii++)
			{
				 pBuffer [0]   = pChar [0] ;
				 pBuffer [128] = pChar [8] ;
				 pBuffer++ ;
				 pChar++ ;
			}
			// Add a space between chars for readability
			pBuffer [0]   = 0 ;
			pBuffer [128] = 0 ;
			// Increment the virtual cursor position
			cx += 9 ;
			if (cx > 127)
			{
				cx -= 128 ;
				cy = (cy + 16) & 0x3F ;
			}
		}
	}
}

//--------------------------------------------------------------------------------
//	Very simple bitmap display
//	The height and Y position of the bitmap must be a multiple of page height (8 bits)
//	Use displaySetPos() to set the top/left corner of the bitmap
//	BEWARE: There is no displayBuffer overflow protection

void	displayBitmap (const uint8_t * pBitmap, uint32_t width, uint32_t height)
{
	uint8_t		* pBuffer ;
	uint32_t	ll, bb ;

	cy = cy  & 0x038 ;		// Adjust cy to multiple of 8
	for (ll = 0 ; ll < height ; ll += 8)
	{
		pBuffer = & displayBuffer [((cy / 8) * DISPLAY_WIDTH) + cx] ; // Where to copy the bitmap
		for (bb = 0 ; bb < width ; bb++)
		{
			* pBuffer++ = * pBitmap++ ;
		}
		cy += 8 ;
	}

}

//--------------------------------------------------------------------------------

void	displayString (const char * pStr)
{
	while (* pStr != 0)
	{
		displayChar (* pStr++) ;
	}
}

//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
// Send a command to the controller

static	void displayWrCmd (unsigned data)
{
	dcCmd () ;
	csSet () ;
	spiTxByte (displaySpi, data) ;
	csReset () ;
}

//--------------------------------------------------------------------------------
// Send a data to the controller
// Rarely used, so add used attribute to avoid compiler warning

static	__attribute__ ((used)) void displayWrData (unsigned cmd)
{
	dcData () ;
	csSet () ;
	spiTxByte (displaySpi, cmd) ;
	csReset () ;
}

//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
// Set pixel coordinates in the display screen

void displaySetPos (unsigned char x, unsigned char y)
{
	cx = x ;
	cy = y ;
}

//--------------------------------------------------------------------------------
// Set pixel coordinates of a character in the display screen
//
void displaySetCharPos (unsigned char pos, unsigned char line)
{
	if (currentFont == FONT_SMALL)
	{
		cx = pos  * FONT_SMALL_W ;
		cy = line * FONT_SMALL_H ;
	}
	else
	{
		cx = pos  * FONT_BIG_W ;
		cy = line * FONT_BIG_H ;
	}
}

//--------------------------------------------------------------------------------
// Exit power saver mode

void displayOn (void)
{
	displayWrCmd (0x8D) ;  // SET DCDC...
	displayWrCmd (0x14) ;  //     DCDC ON
	displayWrCmd (0xAF) ;  // DISPLAY ON
}

//--------------------------------------------------------------------------------
// Enter power saver mode

void displayOff (void)
{
	displayWrCmd (0x8D) ;  // SET DCDC...
	displayWrCmd (0x10) ;  //     DCDC OFF
	displayWrCmd (0xAE) ;  // DISPLAY OFF
}

//--------------------------------------------------------------------------------
// mode 0: normal   (black background)
// mode 1: inverted (white background)

void displayInvert (unsigned mode)
{
	displayWrCmd (0xA6 | (mode & 1u)) ;	// Inverse Display Off/On (0xA6/A7)
}

//--------------------------------------------------------------------------------
// Set a pixel in the local screen buffer
// x: 0..127
// y: 0..63
// color: 1-white 0-black

void displaySetPixel (unsigned char x, unsigned char y, unsigned char color)
{
	if (color == COLOR_WHITE)
	{
		displayBuffer [(y / DISPLAY_PAGE_COUNT) * DISPLAY_WIDTH + x] |=  (1u << (y % DISPLAY_PAGE_COUNT)) & 0xff ;
	}
	else
	{
		displayBuffer [(y / DISPLAY_PAGE_COUNT) * DISPLAY_WIDTH + x] &= ~((1 << (y % DISPLAY_PAGE_COUNT)) & 0xff) ;
	}
}

//--------------------------------------------------------------------------------
// Update the physical screen from the local screen buffer with DMA

void displayUpdate (void)
{
	uint32_t	ii ;
	uint8_t		* pByte ;
	
	if (aaSunCfg.displayController == DISPLAY_SSD1306)
	{
		// SSD1306: Use horizontal addressing mode, can update the screen with only 1 DMA burst
		// Set start of page and column
		displayWrCmd (0xB0) ;	// Setting page address 0
		displayWrCmd (0x10) ;	// Set display position-column high nibble
		displayWrCmd (0x00) ;	// Set display position-column low  nibble

		dcData () ;
		csSet () ;
		spiScreenDmaXfer (DISPLAY_WIDTH*8, displayBuffer) ;
		csReset () ;
	}
	else if (aaSunCfg.displayController == DISPLAY_SH1106)
	{
		// SH1106: use page addressing mode, 1 DMA burst for every page
		pByte = displayBuffer ;
		for (ii = 0 ; ii < DISPLAY_PAGE_COUNT ; ii++)
		{
			// Set start of page and column
			displayWrCmd (SH1106_SETPAGEADDR + ii) ;	// Setting page address 0~7
			displayWrCmd (SH1106_SETHIGHCOLUMN) ;		// Set display position-column high nibble
			displayWrCmd (SH1106_SETLOWCOLUMN) ;		// Set display position-column low  nibble

			// Send one page of data
			dcData () ;
			csSet () ;
			spiScreenDmaXfer (DISPLAY_WIDTH, pByte) ;
			pByte += DISPLAY_WIDTH ;
			csReset () ;
		}
	}
}

//--------------------------------------------------------------------------------
// Clear the local screen buffer
// Doesn't update the screen, use displayUpdate() next

void displayClear (unsigned data)
{
	char cc = (data == 0) ? 0 : 0xFF ;
	memset (displayBuffer, cc, sizeof (displayBuffer)) ;
}

//--------------------------------------------------------------------------------
// Physically reset the display

void displayReset (void)
{
	rstOff () ;
	aaTaskDelay (2) ;
	
	rstOn () ;
	aaTaskDelay (10) ;
	
	rstOff () ;
}

//--------------------------------------------------------------------------------

static	bool	displaySpiTake (void)
{
	bool res ;

	res = spiTryTake (displaySpi) ;
	if (res)
	{
		spiSetBaudRate (displaySpi, SPI_DISPLAY_BRDIV) ;
		spiModeTxOnly  (displaySpi) ;
	}
	return res ;
}

static	void	displaySpiGive	(void)
{
	spiGive (displaySpi) ;
}

//--------------------------------------------------------------------------------
// Display controller initialization

static const uint8_t	SH1106_Config [] =
{
	0xAE,			// Set Display ON/OFF - AE=OFF, AF=ON
	0x8D, 0x10,		// Charge Pump Setting, 14h = Enable Charge Pump
	0x40,			// Set start line address, determine the initial display line or COM0
	0x81, 0xCF,		// Set contrast control register
#if (DISPLAY_FLIP == 0)
	0xA1,			// Set SEG/Column Mapping     0xA0 Invert left/right, 0xA1 normal
	0xC8,			// Set COM/Row Scan Direction 0xC0 Invert top/bottom, 0xC8 normal
#else
	0xA0,			// Set SEG/Column Mapping     0xA0 Invert left/right, 0xA1 normal
	0xC0,			// Set COM/Row Scan Direction 0xC0 Invert top/bottom, 0xC8 normal
#endif
	0xA6,			// Set Normal/Inverse Display mode. A6=Normal; A7=Inverse
	0xA8, 0x3f,		// Set multiplex ratio (0 to 63, height - 1)
	0xD3, 0x00,		// Set display offset Shift Mapping RAM Counter (0x00~0x3F)
	0xD5, 0x80,		// Set display clock divide ratio/oscillator frequency (Set Clock as 100 Frames/Sec)
	0xD9, 0xF1,		// Set pre-charge period: Pre-Charge as 15 Clocks & Discharge as 1 Clock
	0xDA, 0x12,		// Set com pins hardware configuration: Alternative
	0xDB, 0x40,		// Set vcomh: VCOM Deselect Level
	0xA4,			// 0xA4 output follows RAM content; 0xA5 force all ON
	0x8D, 0x14,		// Charge Pump Setting, 14h = Enable Charge Pump
	0xAF,			// Set Display ON/OFF - AE=OFF, AF=ON
} ;

static const uint8_t	SSD1306_Config [] =
{
	0xAE,			// Set Display ON/OFF - AE=OFF, AF=ON
	0x8D, 0x10,		// Charge Pump Setting, 10h = Disble Charge Pump
	0x40,			// Set start line address, at 0.
	0x81, 0xF0,		// Set contrast control register
#if (DISPLAY_FLIP == 0)
	0xA1,			// Set SEG/Column Mapping     0xA0 Invert left/right, 0xA1 normal
	0xC8,			// Set COM/Row Scan Direction 0xC0 Invert top/bottom, 0xC8 normal
#else
	0xA0,			// Set SEG/Column Mapping     0xA0 Invert left/right, 0xA1 normal
	0xC0,			// Set COM/Row Scan Direction 0xC0 Invert top/bottom, 0xC8 normal
#endif
	0xA6,			// Set Normal/Inverse Display mode. A6=Normal; A7=Inverse
	0xA8, 0x3F,		// Set multiplex ratio (0 to 63, height - 1)
	0xD3, 0x00,		// Set display offset. 00 = no offset
	0xD5, 0xF0,		// Set display clock divide ratio/oscillator frequency, set divide ratio
	0xD9, 0x22,		// Set pre-charge period (0x22 or 0xF1)
	0xDA, 0x12,		// Set COM Pins Hardware Configuration - 128x32:0x02,
	0xDB, 0x20,		// Set Vcomh Deselect Level - 0x00: 0.65 x VCC, 0x20: 0.77 x VCC (RESET), 0x30: 0.83 x VCC
	0x20, 0x00,		// Set Memory Addressing Mode - 00=Horizontal, 01=Vertical, 02=Page
	0x2E,			// Deactivate Scroll command
	0x3F,			// Multiplex 64
	0xA4,			// 0xA4 output follows RAM content; 0xA5 force all ON
	0x8D, 0x14,		// Charge Pump Setting, 14h = Enable Charge Pump
	0xAF,			// Set Display ON/OFF - AE=OFF, AF=ON
} ;

void displayInit (void)
{
	uint32_t		count ;
	const uint8_t	* pData ;

	csReset () ;
//	spiInit (displaySpi) ;	// Already done at initialization (reading flash)
	spiScreenDmaInit () ;
	displayReset() ;		// Reset the display

	if (aaSunCfg.displayController != DISPLAY_NONE)
	{
		displaySpiTake () ;
		if (aaSunCfg.displayController == DISPLAY_SH1106)
		{
			count = sizeof (SH1106_Config) ;
			pData = SH1106_Config ;
		}
		else
		{
			count = sizeof (SSD1306_Config) ;
			pData = SSD1306_Config ;
		}
		for (uint32_t ii = 0 ; ii < count ; ii++)
		{
			displayWrCmd (* pData++) ;
		}
		displaySpiGive () ;
	}

    cx = 0 ;
    cy = 0 ;
    currentFont = FONT_SMALL ;
}

//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
// AdAstra-Soft banner

// 'A', 72x48px from https://javl.github.io/image2cpp/
// The draw mode is: Vertical 1 bit per pixel
const uint8_t aaLogo []  =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
	0xc0, 0xc0, 0xc0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0x60, 0x20,
	0xb0, 0xd0, 0x78, 0x38, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x40, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x06, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0xc1, 0x63, 0x33, 0x16,
	0x1c, 0xbe, 0xf3, 0xe1, 0x79, 0x3c, 0x1e, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0x60, 0x30, 0x18, 0x18, 0x0c, 0x0c,
	0x04, 0x84, 0x84, 0x84, 0x04, 0x0c, 0x0c, 0x18, 0x38, 0xf0, 0xc0, 0x00, 0x00, 0x00, 0x80, 0xc0,
	0xc0, 0x60, 0x60, 0x20, 0x20, 0x20, 0x60, 0x60, 0xc0, 0xc0, 0x80, 0x00, 0x80, 0xc0, 0x60, 0x30,
	0x18, 0x0c, 0x06, 0x03, 0xc0, 0xe0, 0xf8, 0x7c, 0x3f, 0x0f, 0x83, 0xff, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3c, 0x0f,
	0x03, 0x00, 0x00, 0xf0, 0xf8, 0x1c, 0x0e, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0xf0, 0x3f, 0x00, 0x00, 0xfe, 0xc7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0x60,
	0x30, 0x19, 0x0f, 0x1e, 0xfb, 0x00, 0x00, 0x80, 0xe0, 0xf8, 0xfc, 0x3f, 0x1f, 0x07, 0x81, 0xc0,
	0x70, 0x1c, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0xc0, 0x00, 0x00, 0x00, 0x0f, 0x1f, 0x38, 0x30, 0x60,
	0x40, 0x40, 0x60, 0x30, 0x10, 0x18, 0x0c, 0x06, 0x03, 0x00, 0x00, 0x80, 0x80, 0xc0, 0x63, 0x76,
	0x3c, 0x18, 0x1c, 0x16, 0x13, 0x31, 0x30, 0x20, 0x20, 0x30, 0xb8, 0xfe, 0xf3, 0x78, 0x3f, 0x1f,
	0x17, 0x13, 0x18, 0x0c, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
	0x07, 0x06, 0x0c, 0x18, 0x18, 0x18, 0x10, 0x10, 0x10, 0x10, 0x18, 0x18, 0x18, 0x08, 0x0c, 0x0c,
	0x06, 0x06, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x18, 0x0c,
	0x0e, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
} ;
static const uint32_t aaLogoW = 72 ;
static const uint32_t aaLogoH = 48 ;

//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
//	Buttons management

#define	BUTTON_MAX		2		// Count of buttons to manage

typedef struct
{
	uint8_t		prevState ;
	uint8_t		count ;

} button_t ;

static	button_t	buttons [BUTTON_MAX] ;
static	uint32_t	buttonState ;

static	const gpioPinDesc_t	buttonDesc  [BUTTON_MAX] =
{
	{	'C',	13,	0,	AA_GPIO_MODE_INPUT_UP },
	{	'C',	14,	0,	AA_GPIO_MODE_INPUT_UP }
} ;

//--------------------------------------------------------------------------------
//	Initialize buttons GPIO

void buttonInit (void)
{
	uint32_t	ii ;

	for (ii = 0 ; ii < BUTTON_MAX ; ii++)
	{
		gpioConfigurePin (& buttonDesc [ii]) ;
	}
}

//--------------------------------------------------------------------------------
// Check the state of the buttons GPIO
// Called from high priority meter task every 10 ms

void buttonPoll (void)
{
	uint32_t	ii ;
	uint32_t	state ;

	for (ii = 0 ; ii < BUTTON_MAX ; ii++)
	{
		state = 1u ^ gpioPinGet (& buttonDesc [ii]) ;	// 1 if the button is pressed
		if (state == 1u)
		{
			if (buttons [ii].prevState == 0u)
			{
				// Rising edge detected, Set the anti-bounce counter
				buttons [ii].count = 2u ;
			}
			else
			{
				if (buttons [ii].count > 0u)
				{
					buttons [ii].count-- ;
					if (buttons [ii].count == 0u)
					{
						// End of anti-bounce counter
						buttonState |= 1u << ii ;	// Pressed and stable
					}
				}
			}
		}

		buttons [ii].prevState = state ;
	}
}

//--------------------------------------------------------------------------------
//	The application gets the current state of the buttons
//	Only the rising edge is reported

uint32_t buttonGet (void)
{
	return buttonState ;
}

//--------------------------------------------------------------------------------
// Acknowledge a button: remove from buttonState

void buttonAck (uint32_t mask)
{
	bspDisableIrq () ;

	buttonState &= ~mask ;

	bspEnableIrq () ;
}

//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
//	Software pulse counters, input and output management

typedef struct
{
	uint8_t		prevState ;
	uint8_t		bounceCount ;
	uint16_t	pulseCount ;
	uint16_t	prevPpulseCount ;

} pulse_t ;

static	pulse_t				pulses [PULSE_COUNTER_MAX] ;

static	const gpioPinDesc_t	inOutDesc  [] =
{
	{	'B',	2,	0,	AA_GPIO_MODE_INPUT_DN },	// Input 1 : 3.3V input of J6
	{	'D',	3,	0,	AA_GPIO_MODE_INPUT_DN },	// Input 2 : 3.3V/5V on expansion connector (E_RX)
	{	'C',	15,	0,	AA_GPIO_MODE_INPUT_UP },	// Input 3 / pulse counter input J8
	{	'B',	11,	0,	AA_GPIO_MODE_INPUT_UP },	// Input 4 / pulse counter input J9

	{	'B',	3,	0,	AA_GPIO_MODE_OUTPUT_PP },	// Output 3 : On board relay
	{	'B',	9,	0,	AA_GPIO_MODE_OUTPUT_PP },	// Output 4 : J3 on expansion connector (E_RX)
} ;

// The indexes in inOutDesc
#define	IDX_IN_1_DIGITAL		0
#define	IDX_IN_2_DIGITAL		1
#define	IDX_IN_3_PULSE_1		2
#define	IDX_IN_4_PULSE_2		3
#define	IDX_OUT_3_RELAY			4
#define	IDX_OUT_4_DIGITAL		5

static const uint32_t inOutDescCount = sizeof (inOutDesc) / sizeof (gpioPinDesc_t) ;

//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
//	Initialize input and output GPIO

void inOutInit (void)
{
	uint32_t	ii ;

	for (ii = 0 ; ii < inOutDescCount ; ii++)
	{
		gpioConfigurePin (& inOutDesc [ii]) ;
	}

	for (ii = 0 ; ii < PULSE_COUNTER_MAX ; ii++)
	{
		pulses [ii].prevState       = 0u ;
		pulses [ii].bounceCount     = 0u ;
		pulses [ii].pulseCount      = 0u ;
		pulses [ii].prevPpulseCount = 0u ;

		pulseCounter [ii].pulsePeriodCount = 0u ;
	}
	pulsePowerPeriod = 0u ;
}

//--------------------------------------------------------------------------------
// Get the value of input at index (0 based)

bool	inputGet (uint32_t index, uint32_t * pValue)
{
	bool	result = true ;

	switch (index)
	{
		case IO_IN1:
			* pValue = gpioPinGet (& inOutDesc [IDX_IN_1_DIGITAL]) ;
			break ;

		case IO_IN2:
			* pValue = gpioPinGet (& inOutDesc [IDX_IN_2_DIGITAL]) ;
			break ;

		case IO_PULSE1:
		case IO_PULSE2:
			index -= IO_PULSE1 ;
			if (pulseCounter [index].pulsepkWh == 0)
			{
				* pValue = 1u ^ gpioPinGet (& inOutDesc[IDX_IN_3_PULSE_1 + index]) ;	// The signal is inverted by the LM393...
			}
			else
			{
				result = false  ;	// This is used as pulse counter
			}
			break ;

		default:
			result = false  ;
			break ;
	}
	return result ;
}

//--------------------------------------------------------------------------------

void	outputSet (uint32_t index, uint32_t value)
{
	switch (index)
	{
		case IO_OUT3:
			gpioPinSet (& inOutDesc [IDX_OUT_3_RELAY], value) ;
			break ;

		case IO_OUT4:
			gpioPinSet (& inOutDesc [IDX_OUT_4_DIGITAL], value) ;
			break ;

		default:
			break ;
	}
}

//--------------------------------------------------------------------------------

void pulsePoll (void)
{
	uint32_t	ii ;
	uint32_t	state ;

	for (ii = 0 ; ii < PULSE_COUNTER_MAX ; ii++)
	{
		if (pulseCounter [ii].pulsepkWh == 0u)
		{
			continue ;	// Unused counter
		}

		state = gpioPinGet (& inOutDesc [IDX_IN_3_PULSE_1 + ii]) ;
		if (state == 1u)
		{
			if (pulses [ii].prevState == 0u)
			{
				// Rising edge detected
				pulses [ii].bounceCount = 1u ;
			}
			else
			{
				if (pulses [ii].bounceCount > 0u)
				{
					pulses [ii].bounceCount-- ;
					pulses [ii].pulseCount++ ;
				}
			}
		}
		pulses [ii].prevState = state ;
	}
}

//--------------------------------------------------------------------------------
// Returns the pulse count since the last call

uint32_t pulseGet (uint32_t ix)
{
	uint32_t	pulseCount ;
	uint32_t	count = 0 ;

	if (ix < PULSE_COUNTER_MAX)
	{
		pulseCount = pulses [ix].pulseCount ;
		count = (pulseCount - pulses [ix].prevPpulseCount) & 0x0FFFF ;
		pulses [ix].prevPpulseCount = pulseCount ;
	}
	return count ;
}

//--------------------------------------------------------------------------------
// For debug and test: increment a pulse counter

void pulseIncr (uint32_t ix, uint32_t count)
{
	if (ix < PULSE_COUNTER_MAX)
	{
		pulses [ix].pulseCount += count ;
	}
}

//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
//	Page display

typedef void (* pageDisplay_t) (void) ;

static	void	pageLogo		(void) ;
static	void	pageVersion		(void) ;
static	void	pageDiverter	(void) ;
static	void	pageI1			(void) ;
static	void	pageI2			(void) ;
#if (defined IX_I3)
static	void	pageI3			(void) ;
#endif
#if (defined IX_I4)
static	void	pageI4			(void) ;
#endif
static	void	pageTemperature	(void) ;
static	void	pageMeter		(void) ;
static	void	pagePeak		(void) ;
#if (defined IX_I3  ||  defined IX_I4)
static	void	pagePeak34		(void) ;
#endif
static	void	pageStatus		(void) ;
static	void	pagePowerAll	(void) ;
static	void	pageEnergy1		(void) ;
static	void	pageEnergy2		(void) ;

static const pageDisplay_t	pages [] =
{
	pageLogo,
	pageVersion,
	pagePowerAll,
	pageEnergy1,
	pageEnergy2,
	pageDiverter,
	pageI1,
	pageI2,
	#if (defined IX_I3)
		pageI3,
	#endif
	#if (defined IX_I4)
		pageI4,
	#endif
	pageTemperature,
	pageMeter,
	pagePeak,
	#if (defined IX_I3  ||  defined IX_I4)
		pagePeak34,
	#endif
	pageStatus,
} ;

static	const int32_t	pageCount = sizeof (pages) / sizeof (pageDisplay_t) ;
static	int32_t			pageIndex ;
static	char			lineBuffer [20] ;	// To build the text to display

//--------------------------------------------------------------------------------
// To call after a button press

void	pageNext (uint32_t next)
{
	if (next == PAGE_DOWN)
	{
		pageIndex++ ;
		if (pageIndex == pageCount)
		{
			pageIndex = 0 ;
		}
	}
	else
	{
		pageIndex-- ;
		if (pageIndex < 0)
		{
			pageIndex = pageCount - 1 ;
		}
	}

	// Display the page
	pageUpdate () ;
}

//--------------------------------------------------------------------------------
//	Set a page index and display the page

void	pageSet (uint32_t index)
{
	pageIndex = index % pageCount ;
	pageUpdate () ;
}

//--------------------------------------------------------------------------------

uint32_t	pageGet		(void)
{
	return pageIndex ;
}

//--------------------------------------------------------------------------------
//	Update the screen

void	pageUpdate (void)
{
	(* pages [pageIndex]) () ;	// Update the buffer in memory

	// Display is low priority: if the SPI is not available then skip
	if (displaySpiTake ())
	{
		displayUpdate () ;		// Send the buffer to the display
		displaySpiGive () ;
	}
}

//--------------------------------------------------------------------------------
//	Display 1 character line in the display buffer with test and value
//	Text or value can be NULL

static void pageLine (int32_t line, const char * pTxt, const char * pValue, int32_t length)
{
	// Displays the test on the left
	if (pTxt != NULL)
	{
		displaySetCharPos (0, line) ;	// x, y
		displayString (pTxt) ;
	}

	// Displays the value on the right
	if (pValue != NULL)
	{
		displaySetCharPos (currentFontNL - length, line) ;	// x, y
		displayString (pValue) ;
	}
}

//--------------------------------------------------------------------------------

static	void	pageLogo (void)
{
	displayClear (0) ;
	displaySetPos (28, 0) ;	// x, y
	displayBitmap (aaLogo, aaLogoW, aaLogoH) ;
	displaySetPos (8, 48) ;
	displaySetFont (FONT_BIG) ;
	displayString (" AdAstra-Soft ") ;
}

//--------------------------------------------------------------------------------

static	void	pageVersion (void)
{
	uint32_t	temp ;

	displayClear (0) ;
	displaySetFont (FONT_BIG) ;

	temp = AASunVersion () ;
	temp = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "V%u.%02u", temp >> 16, temp & 0xFFFFu) ;
	pageLine (0, "AASun", lineBuffer, temp) ;

	temp = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%u.%u.%u.%u",
			aaSunCfg.lanCfg.ip[0], aaSunCfg.lanCfg.ip[1],
			aaSunCfg.lanCfg.ip[2], aaSunCfg.lanCfg.ip[3]) ;
	pageLine (1, NULL, lineBuffer, temp) ;

	temp = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%s %02u:%02u:%02u", timeDayName[localTime.wd], localTime.hh, localTime.mm, localTime.ss) ;
	pageLine (2, statusWTest (STSW_TIME_OK) ? NULL : "?", lineBuffer, temp) ;

	temp = iFracFormat (lineBuffer, computedData.vRms, VOLT_SHIFT, 3, 2) ;
	pageLine (3, "Vrms", lineBuffer, temp) ;
}

//--------------------------------------------------------------------------------
// Display energy counters

static	void	pageEnergy1 (void)
{
	uint32_t	len ;

	displayClear (0) ;
	displaySetFont (FONT_BIG) ;

	pageLine (0, "Energy", "Wh", 2) ;

	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%u", energyWh.energyImported) ;
	pageLine (1, "EImp", lineBuffer, len) ;

	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%u", energyWh.energyExported) ;
	pageLine (2, "EExp", lineBuffer, len) ;

	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%u", energyWh.energyDiverted2) ;
	pageLine (3, "E2", lineBuffer, len) ;
}

static	void	pageEnergy2 (void)
{
	uint32_t	len ;

	displayClear (0) ;
	displaySetFont (FONT_BIG) ;

	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%u", energyWh.energyDiverted1) ;
	pageLine (0, "ED1", lineBuffer, len) ;

	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%u", energyWh.energyDiverted2) ;
	pageLine (1, "ED2", lineBuffer, len) ;

#if (defined IX_I3)
	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%u", energyWh.energy3) ;
	pageLine (2, "E3", lineBuffer, len) ;
#endif
#if (defined IX_I4)
	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%u", energyWh.energy4) ;
	pageLine (3, "E4", lineBuffer, len) ;
#endif
}

//--------------------------------------------------------------------------------
// Display diverting information

static	void	pageDiverter (void)
{
	uint32_t	len ;

	displayClear (0) ;
	displaySetFont (FONT_BIG) ;

	pageLine (0, "Diverter", NULL, 0) ;
	displaySetCharPos (11, 0) ;	// x, y
	if (statusWTest (STSW_DIV_ENABLED) != 0)
	{
		displayString ("On") ;
		displaySetCharPos (9, 0) ;	// x, y
		displayString ((diverterIndex == 0) ? "1" : "2") ;
	}
	else
	{
		displayString ("Off") ;
	}
	if (statusWTest (STSW_DIVERTING_MAX) != 0)
	{
		displaySetCharPos (11, 1) ;	// x, y
		displayString ("MAX") ;
	}

	// Diverted power
	len = iFracFormat (lineBuffer, computedData.powerDiverted, POWER_DIVERTER_SHIFT, 6, 1) ;
	pageLine (3, "W", lineBuffer, len) ;
}

//--------------------------------------------------------------------------------

static	void	pagePowerAll (void)
{
	uint32_t	len ;

	displayClear (0) ;
	displaySetFont (FONT_BIG) ;

	len = iFracFormat (lineBuffer, computedData.iData[0].powerReal, POWER_SHIFT, 6, 1) ;
	pageLine (0, "PImp", lineBuffer, len) ;

	len = iFracFormat (lineBuffer, computedData.powerDiverted, POWER_DIVERTER_SHIFT, 6, 1) ;
	pageLine (1, "PDiv e", lineBuffer, len) ;

	len = iFracFormat (lineBuffer, computedData.iData[1].powerReal, POWER_SHIFT, 6, 1) ;
	pageLine (2, "PDiv", lineBuffer, len) ;

	len = iFracFormat (lineBuffer, computedData.iData[2].powerReal, POWER_SHIFT, 6, 1) ;
	pageLine (3, "PV", lineBuffer, len) ;
}

static	void	pageISensor	(uint32_t ix)
{
	uint32_t	len ;

	displayClear (0) ;
	displaySetFont (FONT_BIG) ;

	aaSnPrintf (lineBuffer, sizeof (lineBuffer), "I%d(A)", ix+1) ;
	displaySetCharPos (0, 0) ;	// x, y
	displayString (lineBuffer) ;

	len = iFracFormat (lineBuffer, computedData.iData[ix].iRms, I_SHIFT, 5, 2) ;
	pageLine (0, NULL, lineBuffer, len) ;

	len = iFracFormat (lineBuffer, computedData.iData[ix].powerReal, POWER_SHIFT, 6, 1) ;
	pageLine (1, "PR(W)", lineBuffer, len) ;

	len = iFracFormat (lineBuffer, computedData.iData[ix].powerApp, POWER_SHIFT, 6, 1) ;
	pageLine (2, "PA(VA)", lineBuffer, len) ;

	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%d", computedData.iData[ix].cosPhi) ;
	pageLine (3, "CosPhi", lineBuffer, len) ;
}


static	void	pageI1	(void)
{
	pageISensor (0) ;
}

static	void	pageI2	(void)
{
	pageISensor (1) ;
}

#if (defined IX_I3)
static	void	pageI3	(void)
{
	pageISensor (2) ;
}
#endif

#if (defined IX_I4)
static	void	pageI4	(void)
{
	pageISensor (3) ;
}
#endif

//--------------------------------------------------------------------------------
// Display information from the meter

static	void	pageMeter	(void)
{
	uint32_t	len ;

	displayClear (0) ;
	displaySetFont (FONT_BIG) ;

	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%d", meterVolt) ;
	pageLine (0, "Volt", lineBuffer, len) ;

	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%d", meterBase) ;
	pageLine (1, "BASE", lineBuffer, len) ;

	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%d", meterPapp) ;
	pageLine (2, "PAPP", lineBuffer, len) ;
}

//--------------------------------------------------------------------------------

static	void	pageTemperature	(void)
{
	ds18b20_t	* pTemp = & pTempSensors->sensors [0] ;
	uint32_t	len ;
	uint32_t	ii, nn ;
	char		label [4] = "T1" ;

	displayClear (0) ;
	displaySetFont (FONT_BIG) ;

	nn = 0 ;
	for (ii = 0 ; ii < TEMP_SENSOR_MAX ; ii++)
	{
		if (pTemp->rawTemp != DS18X20_INVALID_RAW_TEMP)
		{
			len = iFracFormat (lineBuffer, pTemp->rawTemp, TEMP_SENSOR_SHIFT, 3, 1) ;
			label [1] = '1' + ii ;
			pageLine (ii, label, lineBuffer, len) ;
			nn++ ;
		}
		pTemp++ ;
	}
	if (nn == 0)
	{
		pageLine (0, "No temperature", NULL, 0) ;
	}
}

//--------------------------------------------------------------------------------

static	void	pagePeak	(void)
{
	uint32_t	len ;

	displayClear (0) ;
	displaySetFont (FONT_BIG) ;
	displaySetCharPos (0, 0) ;	// x, y
	displayString ("Peak (LSB)") ;

	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%4d %4d", acquiredData.vPeakAdcP, acquiredData.vPeakAdcM) ;
	pageLine (1, "V", lineBuffer, len) ;

	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%4d %4d", acquiredData.iData[0].iPeakAdcP, acquiredData.iData[0].iPeakAdcM) ;
	pageLine (2, "I1", lineBuffer, len) ;

	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%4d %4d", acquiredData.iData[1].iPeakAdcP, acquiredData.iData[1].iPeakAdcM) ;
	pageLine (3, "I2", lineBuffer, len) ;
}

//--------------------------------------------------------------------------------

#if (defined IX_I3  ||  defined IX_I4)
static	void	pagePeak34	(void)
{
	uint32_t	len ;

	displayClear (0) ;
	displaySetFont (FONT_BIG) ;
	displaySetCharPos (0, 0) ;	// x, y
	displayString ("Peak (LSB)") ;

	#if (defined IX_I3)
	len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%4d %4d", acquiredData.iData[2].iPeakAdcP, acquiredData.iData[2].iPeakAdcM) ;
		pageLine (1, "I3", lineBuffer, len) ;
	#endif

	#if (defined IX_I4)
		len = aaSnPrintf (lineBuffer, sizeof (lineBuffer), "%4d %4d", acquiredData.iData[3].iPeakAdcP, acquiredData.iData[3].iPeakAdcM) ;
		pageLine (2, "I4", lineBuffer, len) ;
	#endif
}
#endif

//--------------------------------------------------------------------------------
// Displays the statusWord content:
// On line A bits: 000000XX		mainly status bits
// On line B bits: 0000XX00		mainly error  bits
// On line C bits: 00XX0000

static	void	pageStatus	(void)
{
	uint32_t	sts ;
	uint32_t	ii, jj ;
	char		* pStr ;

	displayClear (0) ;
	displaySetFont (FONT_BIG) ;
	displaySetCharPos (0, 0) ;	// x, y
	displayString ("   7654  3210") ;

	sts = statusWord ;
	for (ii = 0 ; ii < 3 ; ii++)
	{
		pStr = lineBuffer ;
		* pStr++ = 'C' - ii ;
		* pStr++ = ':' ;
		* pStr++ = ' ' ;
		for (jj = 0 ; jj < 8 ; jj++)
		{
			* pStr++ = ((sts & 0x00800000u) == 0u) ? '.' : 'X' ;
			sts <<= 1 ;
			if (jj == 3)
			{
				* pStr++ = ' ' ;
				* pStr++ = ' ' ;
			}
		}
		displaySetCharPos (0, 3-ii) ;	// x, y
		displayString (lineBuffer) ;
	}
}

//--------------------------------------------------------------------------------

